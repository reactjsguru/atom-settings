"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./domain/index");
var ChromeDebuggingRequester = (function () {
    function ChromeDebuggingRequester(socket) {
        var _this = this;
        this.socket = socket;
        this.nextRequestId = 0;
        this.subscriptions = [];
        this.log = false;
        this.domains = {
            Console: new index_1.ConsoleDomain(this),
            Page: new index_1.PageDomain(this),
            Debugger: new index_1.DebuggerDomain(this),
            Runtime: new index_1.RuntimeDomain(this),
            Profiler: new index_1.ProfilerDomain(this)
        };
        socket.on('message', function (message) {
            var response = JSON.parse(message);
            _this.responseHandler(response);
        });
    }
    ChromeDebuggingRequester.prototype.enableLogging = function () {
        this.log = true;
    };
    ChromeDebuggingRequester.prototype.getDomains = function () {
        return this.domains;
    };
    ChromeDebuggingRequester.prototype.responseHandler = function (response) {
        if (Number(response.id) >= 0 && this.subscriptions[response.id]) {
            var subscription = this.subscriptions[response.id];
            if (response.result) {
                subscription.resolve(response.result);
            }
            else {
                subscription.reject(response.error);
            }
        }
        else if (response.error) {
            if (this.log)
                console.log('unhandled error', response);
        }
        else {
            var parse = String(response.method).split('.');
            var domainName = parse[0];
            var methodName = parse[1];
            var domain = this.domains[domainName];
            if (domain) {
                this.domains[domainName].emit(methodName, response.params);
            }
            else {
                if (this.log)
                    console.log('unhandled method', response);
            }
        }
    };
    ChromeDebuggingRequester.prototype.send = function (method, params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var options = {
                id: _this.nextRequestId,
                method: method
            };
            if (params) {
                options.params = params;
            }
            _this.subscriptions[options.id] = {
                resolve: resolve,
                reject: reject
            };
            var body = JSON.stringify(options);
            _this.socket.send(body);
            if (_this.log)
                console.log('sending', body);
            _this.nextRequestId++;
        });
    };
    return ChromeDebuggingRequester;
}());
exports.ChromeDebuggingRequester = ChromeDebuggingRequester;
//# sourceMappingURL=chrome-debugging-requester.js.map